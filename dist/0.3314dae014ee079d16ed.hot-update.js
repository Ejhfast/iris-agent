webpackHotUpdate(0,{

/***/ 501:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setInput = exports.PredictionStrip = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _react = __webpack_require__(2);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _InputBox = __webpack_require__(130);\n\nvar _python = __webpack_require__(61);\n\nvar _index = __webpack_require__(35);\n\nvar _reactRedux = __webpack_require__(30);\n\nvar _lodash = __webpack_require__(140);\n\nvar _ = _interopRequireWildcard(_lodash);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// set main input text and update hint\nvar setInput = function setInput(dispatch, text, id) {\n  return function () {\n    var stripText = text.replace(/{/g, '').replace(/}/g, '');\n    _InputBox.input.value = stripText;\n    (0, _python.updateHint)(stripText);\n    dispatch((0, _index.storeClassIndex)(id));\n  };\n};\n\nvar normalStyle = function normalStyle(lst) {\n  return [_.map(lst, function (p) {\n    return _extends({}, p, { style: \"normal\" });\n  })];\n};\n\nvar selectedStyle = function selectedStyle(lst) {\n  return [_.map(lst, function (p) {\n    return _extends({}, p, { style: \"c0\" });\n  })];\n};\n\nvar reorder = function reorder(currIndex, predictions) {\n  console.log(currIndex, predictions);\n  return [].concat(_toConsumableArray(selectedStyle(_.filter(predictions, function (p) {\n    return p.id === currIndex;\n  }))), _toConsumableArray(normalStyle(_.filter(predictions, function (p) {\n    return p.id !== currIndex;\n  }))));\n};\n\n// TODO: should logic that binds to tab-key press be here as well?\n\n// defines component for prediction strip above main input text\nvar PredictionStrip = function PredictionStrip(_ref) {\n  var dispatch = _ref.dispatch,\n      predictions = _ref.predictions,\n      currIndex = _ref.currIndex;\n\n  // TODO: optimize width\n  var charLength = predictions.map(function (p) {\n    return p.text.length;\n  }).reduce(function (x, y) {\n    return x + y;\n  }, 0);\n  return _react2.default.createElement(\n    'div',\n    { className: 'prediction_strip' },\n    _react2.default.createElement(\n      'div',\n      { className: 'predictions', style: { width: charLength * 9 + \"px\" } },\n      reorder(currIndex, predictions).map(function (obj, i) {\n        return _react2.default.createElement(\n          'span',\n          { onClick: setInput(dispatch, obj.text, obj.id), className: \"prediction \" + obj.style },\n          obj.text\n        );\n      })\n    )\n  );\n};\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    predictions: state.predictions,\n    currIndex: state.currentInput.classIndex // for selected prediction\n  };\n};\n\nexports.PredictionStrip = PredictionStrip = (0, _reactRedux.connect)(mapStateToProps)(PredictionStrip);\n\nexports.PredictionStrip = PredictionStrip;\nexports.setInput = setInput;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9QcmVkaWN0aW9uU3RyaXAuanM/ZDFhMiJdLCJuYW1lcyI6WyJfIiwic2V0SW5wdXQiLCJkaXNwYXRjaCIsInRleHQiLCJpZCIsInN0cmlwVGV4dCIsInJlcGxhY2UiLCJ2YWx1ZSIsIm5vcm1hbFN0eWxlIiwibHN0IiwibWFwIiwicCIsInN0eWxlIiwic2VsZWN0ZWRTdHlsZSIsInJlb3JkZXIiLCJjdXJySW5kZXgiLCJwcmVkaWN0aW9ucyIsImNvbnNvbGUiLCJsb2ciLCJmaWx0ZXIiLCJQcmVkaWN0aW9uU3RyaXAiLCJjaGFyTGVuZ3RoIiwibGVuZ3RoIiwicmVkdWNlIiwieCIsInkiLCJ3aWR0aCIsIm9iaiIsImkiLCJtYXBTdGF0ZVRvUHJvcHMiLCJzdGF0ZSIsImN1cnJlbnRJbnB1dCIsImNsYXNzSW5kZXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0lBQVlBLEM7Ozs7Ozs7O0FBRVo7QUFDQSxJQUFNQyxXQUFXLFNBQVhBLFFBQVcsQ0FBQ0MsUUFBRCxFQUFXQyxJQUFYLEVBQWlCQyxFQUFqQixFQUF3QjtBQUNyQyxTQUFPLFlBQU07QUFDVCxRQUFJQyxZQUFZRixLQUFLRyxPQUFMLENBQWEsSUFBYixFQUFtQixFQUFuQixFQUF1QkEsT0FBdkIsQ0FBK0IsSUFBL0IsRUFBcUMsRUFBckMsQ0FBaEI7QUFDQSxvQkFBTUMsS0FBTixHQUFjRixTQUFkO0FBQ0EsNEJBQVdBLFNBQVg7QUFDQUgsYUFBUyw0QkFBZ0JFLEVBQWhCLENBQVQ7QUFDSCxHQUxEO0FBTUgsQ0FQRDs7QUFTQSxJQUFNSSxjQUFjLFNBQWRBLFdBQWMsQ0FBQ0MsR0FBRCxFQUFTO0FBQzNCLFNBQU8sQ0FBQ1QsRUFBRVUsR0FBRixDQUFNRCxHQUFOLEVBQVcsVUFBQ0UsQ0FBRCxFQUFPO0FBQUUsd0JBQVdBLENBQVgsSUFBY0MsT0FBTyxRQUFyQjtBQUFpQyxHQUFyRCxDQUFELENBQVA7QUFDRCxDQUZEOztBQUlBLElBQU1DLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBQ0osR0FBRCxFQUFTO0FBQzdCLFNBQU8sQ0FBQ1QsRUFBRVUsR0FBRixDQUFNRCxHQUFOLEVBQVcsVUFBQ0UsQ0FBRCxFQUFPO0FBQUUsd0JBQVdBLENBQVgsSUFBY0MsT0FBTyxJQUFyQjtBQUE2QixHQUFqRCxDQUFELENBQVA7QUFDRCxDQUZEOztBQUlBLElBQU1FLFVBQVUsU0FBVkEsT0FBVSxDQUFDQyxTQUFELEVBQVlDLFdBQVosRUFBNEI7QUFDMUNDLFVBQVFDLEdBQVIsQ0FBWUgsU0FBWixFQUF1QkMsV0FBdkI7QUFDQSxzQ0FBWUgsY0FBY2IsRUFBRW1CLE1BQUYsQ0FBU0gsV0FBVCxFQUFzQixVQUFDTCxDQUFEO0FBQUEsV0FBT0EsRUFBRVAsRUFBRixLQUFTVyxTQUFoQjtBQUFBLEdBQXRCLENBQWQsQ0FBWixzQkFDWVAsWUFBWVIsRUFBRW1CLE1BQUYsQ0FBU0gsV0FBVCxFQUFzQixVQUFDTCxDQUFEO0FBQUEsV0FBT0EsRUFBRVAsRUFBRixLQUFTVyxTQUFoQjtBQUFBLEdBQXRCLENBQVosQ0FEWjtBQUVELENBSkQ7O0FBTUE7O0FBRUE7QUFDQSxJQUFJSyxrQkFBa0IsK0JBQXdDO0FBQUEsTUFBdENsQixRQUFzQyxRQUF0Q0EsUUFBc0M7QUFBQSxNQUE1QmMsV0FBNEIsUUFBNUJBLFdBQTRCO0FBQUEsTUFBZkQsU0FBZSxRQUFmQSxTQUFlOztBQUM1RDtBQUNBLE1BQU1NLGFBQWFMLFlBQVlOLEdBQVosQ0FBZ0IsVUFBQ0MsQ0FBRDtBQUFBLFdBQU9BLEVBQUVSLElBQUYsQ0FBT21CLE1BQWQ7QUFBQSxHQUFoQixFQUFzQ0MsTUFBdEMsQ0FBNkMsVUFBQ0MsQ0FBRCxFQUFHQyxDQUFIO0FBQUEsV0FBU0QsSUFBSUMsQ0FBYjtBQUFBLEdBQTdDLEVBQTZELENBQTdELENBQW5CO0FBQ0EsU0FBUTtBQUFBO0FBQUEsTUFBSyxXQUFVLGtCQUFmO0FBQ0Y7QUFBQTtBQUFBLFFBQUssV0FBVSxhQUFmLEVBQTZCLE9BQU8sRUFBQ0MsT0FBUUwsYUFBYSxDQUFkLEdBQW1CLElBQTNCLEVBQXBDO0FBQ0dQLGNBQVFDLFNBQVIsRUFBbUJDLFdBQW5CLEVBQWdDTixHQUFoQyxDQUFvQyxVQUFDaUIsR0FBRCxFQUFLQyxDQUFMO0FBQUEsZUFBVztBQUFBO0FBQUEsWUFBTSxTQUFTM0IsU0FBU0MsUUFBVCxFQUFtQnlCLElBQUl4QixJQUF2QixFQUE2QndCLElBQUl2QixFQUFqQyxDQUFmLEVBQXFELFdBQVcsZ0JBQWdCdUIsSUFBSWYsS0FBcEY7QUFBNkZlLGNBQUl4QjtBQUFqRyxTQUFYO0FBQUEsT0FBcEM7QUFESDtBQURFLEdBQVI7QUFLRCxDQVJEOztBQVlBLElBQU0wQixrQkFBa0IsU0FBbEJBLGVBQWtCLENBQUNDLEtBQUQ7QUFBQSxTQUFZO0FBQ2hDZCxpQkFBYWMsTUFBTWQsV0FEYTtBQUVoQ0QsZUFBV2UsTUFBTUMsWUFBTixDQUFtQkMsVUFGRSxDQUVTO0FBRlQsR0FBWjtBQUFBLENBQXhCOztBQUtBLFFBRVFaLGVBRlIscUJBQWtCLHlCQUFRUyxlQUFSLEVBQXlCVCxlQUF6QixDQUFsQjs7UUFFUUEsZSxHQUFBQSxlO1FBQWlCbkIsUSxHQUFBQSxRIiwiZmlsZSI6IjUwMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbnB1dCB9IGZyb20gJy4uL2NvbnRhaW5lcnMvSW5wdXRCb3gnO1xuaW1wb3J0IHsgdXBkYXRlSGludCB9IGZyb20gJy4uL2FwaV9jYWxscy9weXRob24uanMnO1xuaW1wb3J0IHsgc3RvcmVDbGFzc0luZGV4LCBjbGVhckNsYXNzSW5kZXggfSBmcm9tICcuLi9hY3Rpb25zL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5cbi8vIHNldCBtYWluIGlucHV0IHRleHQgYW5kIHVwZGF0ZSBoaW50XG5jb25zdCBzZXRJbnB1dCA9IChkaXNwYXRjaCwgdGV4dCAsaWQpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsZXQgc3RyaXBUZXh0ID0gdGV4dC5yZXBsYWNlKC97L2csICcnKS5yZXBsYWNlKC99L2csICcnKTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSBzdHJpcFRleHQ7XG4gICAgICAgIHVwZGF0ZUhpbnQoc3RyaXBUZXh0KTtcbiAgICAgICAgZGlzcGF0Y2goc3RvcmVDbGFzc0luZGV4KGlkKSk7XG4gICAgfTtcbn07XG5cbmNvbnN0IG5vcm1hbFN0eWxlID0gKGxzdCkgPT4ge1xuICByZXR1cm4gW18ubWFwKGxzdCwgKHApID0+IHsgcmV0dXJuIHsuLi5wLCBzdHlsZTogXCJub3JtYWxcIn07IH0pXTtcbn07XG5cbmNvbnN0IHNlbGVjdGVkU3R5bGUgPSAobHN0KSA9PiB7XG4gIHJldHVybiBbXy5tYXAobHN0LCAocCkgPT4geyByZXR1cm4gey4uLnAsIHN0eWxlOiBcImMwXCJ9OyB9KV07XG59O1xuXG5jb25zdCByZW9yZGVyID0gKGN1cnJJbmRleCwgcHJlZGljdGlvbnMpID0+IHtcbiAgY29uc29sZS5sb2coY3VyckluZGV4LCBwcmVkaWN0aW9ucyk7XG4gIHJldHVybiBbLi4uKHNlbGVjdGVkU3R5bGUoXy5maWx0ZXIocHJlZGljdGlvbnMsIChwKSA9PiBwLmlkID09PSBjdXJySW5kZXgpKSksXG4gICAgICAgICAgLi4uKG5vcm1hbFN0eWxlKF8uZmlsdGVyKHByZWRpY3Rpb25zLCAocCkgPT4gcC5pZCAhPT0gY3VyckluZGV4KSkpXVxufTtcblxuLy8gVE9ETzogc2hvdWxkIGxvZ2ljIHRoYXQgYmluZHMgdG8gdGFiLWtleSBwcmVzcyBiZSBoZXJlIGFzIHdlbGw/XG5cbi8vIGRlZmluZXMgY29tcG9uZW50IGZvciBwcmVkaWN0aW9uIHN0cmlwIGFib3ZlIG1haW4gaW5wdXQgdGV4dFxubGV0IFByZWRpY3Rpb25TdHJpcCA9ICh7ZGlzcGF0Y2gsIHByZWRpY3Rpb25zLCBjdXJySW5kZXh9KSA9PiB7XG4gIC8vIFRPRE86IG9wdGltaXplIHdpZHRoXG4gIGNvbnN0IGNoYXJMZW5ndGggPSBwcmVkaWN0aW9ucy5tYXAoKHApID0+IHAudGV4dC5sZW5ndGgpLnJlZHVjZSgoeCx5KSA9PiB4ICsgeSwgMCk7XG4gIHJldHVybiAoPGRpdiBjbGFzc05hbWU9XCJwcmVkaWN0aW9uX3N0cmlwXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJlZGljdGlvbnNcIiBzdHlsZT17e3dpZHRoOiAoY2hhckxlbmd0aCAqIDkpICsgXCJweFwifX0+XG4gICAgICAgICAge3Jlb3JkZXIoY3VyckluZGV4LCBwcmVkaWN0aW9ucykubWFwKChvYmosaSkgPT4gPHNwYW4gb25DbGljaz17c2V0SW5wdXQoZGlzcGF0Y2gsIG9iai50ZXh0LCBvYmouaWQpfSBjbGFzc05hbWU9e1wicHJlZGljdGlvbiBcIiArIG9iai5zdHlsZX0+eyBvYmoudGV4dCB9PC9zcGFuPil9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+KTtcbn07XG5cblxuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSAoc3RhdGUpID0+ICh7XG4gICAgcHJlZGljdGlvbnM6IHN0YXRlLnByZWRpY3Rpb25zLFxuICAgIGN1cnJJbmRleDogc3RhdGUuY3VycmVudElucHV0LmNsYXNzSW5kZXggLy8gZm9yIHNlbGVjdGVkIHByZWRpY3Rpb25cbn0pO1xuXG5QcmVkaWN0aW9uU3RyaXAgPSBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcykoUHJlZGljdGlvblN0cmlwKTtcblxuZXhwb3J0IHtQcmVkaWN0aW9uU3RyaXAsIHNldElucHV0fTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9jb21wb25lbnRzL1ByZWRpY3Rpb25TdHJpcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ })

})