webpackHotUpdate(0,{

/***/ 434:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _reactRouterRedux = __webpack_require__(379);\n\nvar _redux = __webpack_require__(258);\n\nvar _types = __webpack_require__(265);\n\nvar types = _interopRequireWildcard(_types);\n\nvar _lodash = __webpack_require__(154);\n\nvar _ = _interopRequireWildcard(_lodash);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar valueOrNull = function valueOrNull(value) {\n    if (value !== undefined) {\n        return value;\n    }\n    return null;\n};\n\nvar appendMessages = function appendMessages(oldMessages, action) {\n    // text, origin = 'user', type = null, arg = null) => {\n    var newMessages = [];\n    var currentMax = 0;\n    if (oldMessages.length > 0) {\n        console.log('map', _.map(oldMessages, function (m) {\n            return m.id;\n        }));\n        currentMax = _.max(_.map(oldMessages, function (m) {\n            return m.id;\n        }));\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = action.text[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var m = _step.value;\n\n            currentMax++;\n            newMessages.push({ 'origin': action.origin, 'text': m, 'id': currentMax,\n                'state': valueOrNull(action.state), 'arg': valueOrNull(action.arg) });\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return oldMessages.concat(newMessages);\n};\n\nvar appendMessagesConvo = function appendMessagesConvo(convo, action) {\n    var messages = convo.messages;\n\n    return _extends({}, convo, { messages: appendMessages(messages, action), args: action.arg_map });\n};\n\nvar conversation = function conversation() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { 'history': [], 'currentConvo': { 'messages': [], 'title': null, 'hidden': false, 'id': 0, 'args': {} }, 'state': 'START' };\n    var action = arguments[1];\n    var history = state.history,\n        currentConvo = state.currentConvo;\n\n    var newConvo = void 0;\n    switch (action.type) {\n        case types.UPDATE_HISTORY:\n            console.log(action.conversation.currentConvo);\n            return { history: action.conversation.history, currentConvo: action.conversation.currentConvo, 'state': state.state };\n        case types.ADD_MESSAGE:\n            return { history: history, currentConvo: appendMessagesConvo(currentConvo, action), 'state': state.state };\n        case types.ADD_SERVER_MESSAGE:\n            if (action.text.length === 0) {\n                return state;\n            }\n            newConvo = appendMessagesConvo(currentConvo, action);\n            if (action.state === 'START') {\n                // hardcoding some logic here for syncing history with server on START\n                // this allows some commands to overwrite history immediately\n                var theId = action.history.length;\n                newConvo = _extends({}, newConvo, { title: action.label, id: theId });\n                return { history: action.history.concat([newConvo]), 'currentConvo': { 'messages': [], 'title': null, 'hidden': false, 'id': newConvo.id + 1, 'args': {} }, state: 'START' };\n            }\n            return { history: history, currentConvo: newConvo, state: action.state };\n        case types.HIDE_CONVERSATION:\n            var newHistory = _.map(history, function (conv) {\n                var out = _extends({}, conv);\n                if (conv.id === action.id) {\n                    out.hidden = !out.hidden;\n                }\n                return out;\n            });\n            newConvo = _extends({}, currentConvo);\n            if (newConvo.id === action.id) {\n                newConvo.hidden = !newConvo.hidden;\n            }\n            return { history: newHistory, currentConvo: newConvo, state: state.state };\n        default:\n            return state;\n    }\n};\n\nvar variables = function variables() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.UPDATE_VARIABLES:\n            return action.variables;\n        default:\n            return state;\n    }\n};\n\nvar predictions = function predictions() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.UPDATE_PREDICTIONS:\n            return action.predictions;\n        default:\n            return state;\n    }\n};\n\nvar currentInput = function currentInput() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { 'currentInput': '' };\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.STORE_CURRENT_INPUT:\n            return { 'currentInput': action.currentInput };\n        default:\n            return state;\n    }\n};\n\nvar inputHistory = function inputHistory() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { 'history': [], 'currId': null, 'showHistory': false };\n    var action = arguments[1];\n\n    var newId = void 0;\n    switch (action.type) {\n        case types.ADD_INPUT_HISTORY:\n            newId = state.currId;\n            if (state.history.length === 0 && newId === null) {\n                newId = 0;\n            }\n            return _extends({}, state, { 'history': [].concat(_toConsumableArray(state.history), [action.message]), 'currId': newId });\n        case types.MOVE_INPUT_HISTORY:\n            if (state.history.length === 0) {\n                return state;\n            }\n            newId = state.currId || 0;\n            if (action.direction === 'up') {\n                if (newId < state.history.length - 1) {\n                    newId += 1;\n                }\n            } else {\n                if (newId >= 1) {\n                    newId -= 1;\n                }\n            }\n            return _extends({}, state, { 'currId': newId });\n        default:\n            return state;\n    }\n};\n\nvar rootReducer = (0, _redux.combineReducers)({\n    conversation: conversation,\n    variables: variables,\n    predictions: predictions,\n    inputHistory: inputHistory,\n    currentInput: currentInput,\n    routing: _reactRouterRedux.routerReducer\n});\n\nexports.default = rootReducer;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvcmVkdWNlcnMvaW5kZXguanM/ZTkxNiJdLCJuYW1lcyI6WyJ0eXBlcyIsIl8iLCJ2YWx1ZU9yTnVsbCIsInZhbHVlIiwidW5kZWZpbmVkIiwiYXBwZW5kTWVzc2FnZXMiLCJvbGRNZXNzYWdlcyIsImFjdGlvbiIsIm5ld01lc3NhZ2VzIiwiY3VycmVudE1heCIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJtYXAiLCJtIiwiaWQiLCJtYXgiLCJ0ZXh0IiwicHVzaCIsIm9yaWdpbiIsInN0YXRlIiwiYXJnIiwiY29uY2F0IiwiYXBwZW5kTWVzc2FnZXNDb252byIsImNvbnZvIiwibWVzc2FnZXMiLCJhcmdzIiwiYXJnX21hcCIsImNvbnZlcnNhdGlvbiIsImhpc3RvcnkiLCJjdXJyZW50Q29udm8iLCJuZXdDb252byIsInR5cGUiLCJVUERBVEVfSElTVE9SWSIsIkFERF9NRVNTQUdFIiwiQUREX1NFUlZFUl9NRVNTQUdFIiwidGhlSWQiLCJ0aXRsZSIsImxhYmVsIiwiSElERV9DT05WRVJTQVRJT04iLCJuZXdIaXN0b3J5Iiwib3V0IiwiY29udiIsImhpZGRlbiIsInZhcmlhYmxlcyIsIlVQREFURV9WQVJJQUJMRVMiLCJwcmVkaWN0aW9ucyIsIlVQREFURV9QUkVESUNUSU9OUyIsImN1cnJlbnRJbnB1dCIsIlNUT1JFX0NVUlJFTlRfSU5QVVQiLCJpbnB1dEhpc3RvcnkiLCJuZXdJZCIsIkFERF9JTlBVVF9ISVNUT1JZIiwiY3VycklkIiwibWVzc2FnZSIsIk1PVkVfSU5QVVRfSElTVE9SWSIsImRpcmVjdGlvbiIsInJvb3RSZWR1Y2VyIiwicm91dGluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7SUFBWUEsSzs7QUFDWjs7SUFBWUMsQzs7Ozs7O0FBRVosSUFBTUMsY0FBYyxTQUFkQSxXQUFjLENBQUNDLEtBQUQsRUFBVztBQUMzQixRQUFJQSxVQUFVQyxTQUFkLEVBQXlCO0FBQ3JCLGVBQU9E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QkFBSWpDLE1BQU1TLE9BQU4sQ0FBY25CLE1BQWQsS0FBeUIsQ0FBekIsSUFBOEJ5QyxVQUFVLElBQTVDLEVBQWtEO0FBQzlDQSx3QkFBUSxDQUFSO0FBQ0g7QUFDRCxnQ0FBVy9CLEtBQVgsSUFBa0Isd0NBQWVBLE1BQU1TLE9BQXJCLElBQThCdEIsT0FBTytDLE9BQXJDLEVBQWxCLEVBQWlFLFVBQVVILEtBQTNFO0FBQ0osYUFBS25ELE1BQU11RCxrQkFBWDtBQUNJLGdCQUFJbkMsTUFBTVMsT0FBTixDQUFjbkIsTUFBZCxLQUF5QixDQUE3QixFQUFnQztBQUM1Qix1QkFBT1UsS0FBUDtBQUNIO0FBQ0QrQixvQkFBUS9CLE1BQU1pQyxNQUFOLElBQWdCLENBQXhCO0FBQ0EsZ0JBQUk5QyxPQUFPaUQsU0FBUCxLQUFxQixJQUF6QixFQUErQjtBQUMzQixvQkFBSUwsUUFBUy9CLE1BQU1TLE9BQU4sQ0FBY25CLE1BQWQsR0FBdUIsQ0FBcEMsRUFBd0M7QUFDcEN5Qyw2QkFBUyxDQUFUO0FBQ0g7QUFDSixhQUpELE1BSU87QUFDSCxvQkFBSUEsU0FBUyxDQUFiLEVBQWdCO0FBQ1pBLDZCQUFTLENBQVQ7QUFDSDtBQUNKO0FBQ0QsZ0NBQVcvQixLQUFYLElBQWtCLFVBQVUrQixLQUE1QjtBQUNKO0FBQ0ksbUJBQU8vQixLQUFQO0FBdkJSO0FBeUJILENBM0JEOztBQTZCQSxJQUFNcUMsY0FBYyw0QkFBZ0I7QUFDaEM3Qiw4QkFEZ0M7QUFFaENnQix3QkFGZ0M7QUFHaENFLDRCQUhnQztBQUloQ0ksOEJBSmdDO0FBS2hDRiw4QkFMZ0M7QUFNaENVO0FBTmdDLENBQWhCLENBQXBCOztrQkFTZUQsVyIsImZpbGUiOiI0MzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByb3V0ZXJSZWR1Y2VyIGFzIHJvdXRpbmcgfSBmcm9tICdyZWFjdC1yb3V0ZXItcmVkdXgnO1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0ICogYXMgdHlwZXMgZnJvbSAnLi4vYWN0aW9ucy90eXBlcyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZhbHVlT3JOdWxsID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGFwcGVuZE1lc3NhZ2VzID0gKG9sZE1lc3NhZ2VzLCBhY3Rpb24pID0+IHsgLy8gdGV4dCwgb3JpZ2luID0gJ3VzZXInLCB0eXBlID0gbnVsbCwgYXJnID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IG5ld01lc3NhZ2VzID0gW107XG4gICAgbGV0IGN1cnJlbnRNYXggPSAwO1xuICAgIGlmIChvbGRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdtYXAnLCBfLm1hcChvbGRNZXNzYWdlcywgZnVuY3Rpb24obSkgeyByZXR1cm4gbS5pZDsgfSkpO1xuICAgICAgICBjdXJyZW50TWF4ID0gXy5tYXgoXy5tYXAob2xkTWVzc2FnZXMsIGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0uaWQ7IH0pKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtIG9mIGFjdGlvbi50ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRNYXgrKztcbiAgICAgICAgbmV3TWVzc2FnZXMucHVzaCh7J29yaWdpbic6IGFjdGlvbi5vcmlnaW4sICd0ZXh0JzogbSwgJ2lkJzogY3VycmVudE1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXRlJzogdmFsdWVPck51bGwoYWN0aW9uLnN0YXRlKSwgJ2FyZyc6IHZhbHVlT3JOdWxsKGFjdGlvbi5hcmcpfSk7XG4gICAgfVxuICAgIHJldHVybiBvbGRNZXNzYWdlcy5jb25jYXQobmV3TWVzc2FnZXMpO1xufTtcblxuY29uc3QgYXBwZW5kTWVzc2FnZXNDb252byA9IChjb252bywgYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgeyBtZXNzYWdlcyB9ID0gY29udm87XG4gICAgcmV0dXJuIHsgLi4uY29udm8sIG1lc3NhZ2VzOiBhcHBlbmRNZXNzYWdlcyhtZXNzYWdlcywgYWN0aW9uKSwgYXJnczogYWN0aW9uLmFyZ19tYXAgfTtcbn07XG5cbmNvbnN0IGNvbnZlcnNhdGlvbiA9IChzdGF0ZSA9IHsnaGlzdG9yeSc6IFtdLCAnY3VycmVudENvbnZvJzogeyAnbWVzc2FnZXMnOiBbXSwgJ3RpdGxlJzogbnVsbCwgJ2hpZGRlbic6IGZhbHNlLCAnaWQnOiAwLCAnYXJncyc6IHt9IH0sICdzdGF0ZSc6ICdTVEFSVCd9LCBhY3Rpb24pID0+IHtcbiAgICBjb25zdCB7IGhpc3RvcnksIGN1cnJlbnRDb252byB9ID0gc3RhdGU7XG4gICAgbGV0IG5ld0NvbnZvO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlcy5VUERBVEVfSElTVE9SWTpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFjdGlvbi5jb252ZXJzYXRpb24uY3VycmVudENvbnZvKTtcbiAgICAgICAgICAgIHJldHVybiB7IGhpc3Rvcnk6IGFjdGlvbi5jb252ZXJzYXRpb24uaGlzdG9yeSwgY3VycmVudENvbnZvOiBhY3Rpb24uY29udmVyc2F0aW9uLmN1cnJlbnRDb252bywgJ3N0YXRlJzogc3RhdGUuc3RhdGUgfTtcbiAgICAgICAgY2FzZSB0eXBlcy5BRERfTUVTU0FHRTpcbiAgICAgICAgICAgIHJldHVybiB7IGhpc3RvcnksIGN1cnJlbnRDb252bzogYXBwZW5kTWVzc2FnZXNDb252byhjdXJyZW50Q29udm8sIGFjdGlvbiksICdzdGF0ZSc6IHN0YXRlLnN0YXRlIH07XG4gICAgICAgIGNhc2UgdHlwZXMuQUREX1NFUlZFUl9NRVNTQUdFOlxuICAgICAgICAgICAgaWYgKGFjdGlvbi50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0NvbnZvID0gYXBwZW5kTWVzc2FnZXNDb252byhjdXJyZW50Q29udm8sIGFjdGlvbik7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnN0YXRlID09PSAnU1RBUlQnKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFyZGNvZGluZyBzb21lIGxvZ2ljIGhlcmUgZm9yIHN5bmNpbmcgaGlzdG9yeSB3aXRoIHNlcnZlciBvbiBTVEFSVFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgYWxsb3dzIHNvbWUgY29tbWFuZHMgdG8gb3ZlcndyaXRlIGhpc3RvcnkgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBsZXQgdGhlSWQgPSBhY3Rpb24uaGlzdG9yeS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbmV3Q29udm8gPSB7Li4ubmV3Q29udm8sIHRpdGxlOiBhY3Rpb24ubGFiZWwsIGlkOiB0aGVJZCB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhpc3Rvcnk6IGFjdGlvbi5oaXN0b3J5LmNvbmNhdChbbmV3Q29udm9dKSwgJ2N1cnJlbnRDb252byc6IHsgJ21lc3NhZ2VzJzogW10sICd0aXRsZSc6IG51bGwsICdoaWRkZW4nOiBmYWxzZSwgJ2lkJzogbmV3Q29udm8uaWQgKyAxLCAnYXJncyc6IHt9IH0sIHN0YXRlOiAnU1RBUlQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBoaXN0b3J5LCBjdXJyZW50Q29udm86IG5ld0NvbnZvLCBzdGF0ZTogYWN0aW9uLnN0YXRlIH07XG4gICAgICAgIGNhc2UgdHlwZXMuSElERV9DT05WRVJTQVRJT046XG4gICAgICAgICAgICBjb25zdCBuZXdIaXN0b3J5ID0gXy5tYXAoaGlzdG9yeSwgY29udiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gey4uLmNvbnZ9O1xuICAgICAgICAgICAgICAgIGlmIChjb252LmlkID09PSBhY3Rpb24uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmhpZGRlbiA9ICFvdXQuaGlkZGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdDb252byA9IHsuLi5jdXJyZW50Q29udm99O1xuICAgICAgICAgICAgaWYgKG5ld0NvbnZvLmlkID09PSBhY3Rpb24uaWQpIHtcbiAgICAgICAgICAgICAgICBuZXdDb252by5oaWRkZW4gPSAhbmV3Q29udm8uaGlkZGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgaGlzdG9yeTogbmV3SGlzdG9yeSwgY3VycmVudENvbnZvOiBuZXdDb252bywgc3RhdGU6IHN0YXRlLnN0YXRlfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG5jb25zdCB2YXJpYWJsZXMgPSAoc3RhdGUgPSBbXSwgYWN0aW9uKSA9PiB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLlVQREFURV9WQVJJQUJMRVM6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLnZhcmlhYmxlcztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG5jb25zdCBwcmVkaWN0aW9ucyA9IChzdGF0ZSA9IFtdLCBhY3Rpb24pID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMuVVBEQVRFX1BSRURJQ1RJT05TOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5wcmVkaWN0aW9ucztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG5jb25zdCBjdXJyZW50SW5wdXQgPSAoc3RhdGUgPSB7J2N1cnJlbnRJbnB1dCc6ICcnfSwgYWN0aW9uKSA9PiB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpe1xuICAgIGNhc2UgdHlwZXMuU1RPUkVfQ1VSUkVOVF9JTlBVVDpcbiAgICAgIHJldHVybiB7J2N1cnJlbnRJbnB1dCc6IGFjdGlvbi5jdXJyZW50SW5wdXR9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5cbmNvbnN0IGlucHV0SGlzdG9yeSA9IChzdGF0ZSA9IHsnaGlzdG9yeSc6IFtdLCAnY3VycklkJzogbnVsbCwgJ3Nob3dIaXN0b3J5JzogZmFsc2UgfSwgYWN0aW9uKSA9PiB7XG4gICAgbGV0IG5ld0lkO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlcy5BRERfSU5QVVRfSElTVE9SWTpcbiAgICAgICAgICAgIG5ld0lkID0gc3RhdGUuY3VycklkO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhpc3RvcnkubGVuZ3RoID09PSAwICYmIG5ld0lkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3SWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgJ2hpc3RvcnknOiBbLi4uc3RhdGUuaGlzdG9yeSwgYWN0aW9uLm1lc3NhZ2VdLCAnY3VycklkJzogbmV3SWR9O1xuICAgICAgICBjYXNlIHR5cGVzLk1PVkVfSU5QVVRfSElTVE9SWTpcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0lkID0gc3RhdGUuY3VycklkIHx8IDA7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLmRpcmVjdGlvbiA9PT0gJ3VwJykge1xuICAgICAgICAgICAgICAgIGlmIChuZXdJZCA8IChzdGF0ZS5oaXN0b3J5Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0lkICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3SWQgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdJZCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7Li4uc3RhdGUsICdjdXJySWQnOiBuZXdJZCB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn07XG5cbmNvbnN0IHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgICBjb252ZXJzYXRpb24sXG4gICAgdmFyaWFibGVzLFxuICAgIHByZWRpY3Rpb25zLFxuICAgIGlucHV0SGlzdG9yeSxcbiAgICBjdXJyZW50SW5wdXQsXG4gICAgcm91dGluZ1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3RSZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL3JlZHVjZXJzL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ })

})