webpackHotUpdate(0,{

/***/ 519:
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _reactRouterRedux = __webpack_require__(440);\n\nvar _redux = __webpack_require__(304);\n\nvar _types = __webpack_require__(320);\n\nvar types = _interopRequireWildcard(_types);\n\nvar _lodash = __webpack_require__(123);\n\nvar _ = _interopRequireWildcard(_lodash);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// TODO: a bit confused why we need this function\nvar valueOrNull = function valueOrNull(value) {\n    if (value !== undefined) {\n        return value;\n    }\n    return null;\n};\n\n// given an action, push any new messages onto an existing set of messages\nvar appendMessages = function appendMessages(oldMessages, action) {\n    var newMessages = [];\n    var currentMax = 0;\n    if (oldMessages.length > 0) {\n        console.log('map', _.map(oldMessages, function (m) {\n            return m.id;\n        }));\n        currentMax = _.max(_.map(oldMessages, function (m) {\n            return m.id;\n        }));\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = action.text[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var m = _step.value;\n\n            currentMax++;\n            var class_index = action.class_index !== undefined ? action.class_index : null;\n            newMessages.push({ 'origin': action.origin, 'text': m, 'id': currentMax, 'class_index': class_index,\n                'state': valueOrNull(action.state), 'arg': valueOrNull(action.arg) });\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return oldMessages.concat(newMessages);\n};\n\n// given an action, update a conversation with new messages\nvar appendMessagesConvo = function appendMessagesConvo(convo, action) {\n    var messages = convo.messages;\n\n    return _extends({}, convo, { messages: appendMessages(messages, action), args: action.arg_map });\n};\n\n// reducer for conversations\n// TODO: This definition state is pretty long, messy\n// Also not clear what \"args\" represents in a conversation with multiple sub-convos\n// Maybe it is only important to represent the convo title, if so maybe that should be refactored\nvar conversation = function conversation() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { 'history': [], 'currentConvo': { 'messages': [], 'title': null, 'hidden': false, 'id': 0, 'args': {} }, 'state': 'START' };\n    var action = arguments[1];\n    var history = state.history,\n        currentConvo = state.currentConvo;\n\n    var newConvo = void 0;\n    switch (action.type) {\n        case types.UPDATE_HISTORY:\n            console.log(action.conversation.currentConvo);\n            return { history: action.conversation.history, currentConvo: action.conversation.currentConvo, 'state': state.state };\n        case types.ADD_MESSAGE:\n            return { history: history, currentConvo: appendMessagesConvo(currentConvo, action), 'state': state.state };\n        // this is a bit complex, maybe needs review for clarity\n        case types.ADD_SERVER_MESSAGE:\n            if (action.text.length === 0) {\n                return state;\n            }\n            newConvo = appendMessagesConvo(currentConvo, action);\n            if (action.state === 'START') {\n                // hardcoding some logic here for syncing history with server on START\n                // this allows some commands to overwrite history immediately\n                var theId = action.history.length;\n                newConvo = _extends({}, newConvo, { title: action.label, id: theId });\n                return { history: action.history.concat([newConvo]), 'currentConvo': { 'messages': [], 'title': null, 'hidden': false, 'id': newConvo.id + 1, 'args': {} }, state: 'START' };\n            }\n            return { history: history, currentConvo: newConvo, state: action.state };\n        case types.HIDE_CONVERSATION:\n            // this is super verbose just to update a specific convo index, better way?\n            var newHistory = _.map(history, function (conv) {\n                var out = _extends({}, conv);\n                if (conv.id === action.id) {\n                    out.hidden = !out.hidden;\n                }\n                return out;\n            });\n            // TODO: also wasteful to do a copy everytime, indendent of the index?\n            newConvo = _extends({}, currentConvo);\n            if (newConvo.id === action.id) {\n                newConvo.hidden = !newConvo.hidden;\n            }\n            return { history: newHistory, currentConvo: newConvo, state: state.state };\n        default:\n            return state;\n    }\n};\n\n// variables reducer, constrols variables in right sidebar\nvar variables = function variables() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.UPDATE_VARIABLES:\n            return action.variables;\n        case types.TOGGLE_VARIABLE_ATTRIBUTES:\n            var newVariables = state.concat([]);\n            newVariables[action.index] = action.values;\n            return state;\n        default:\n            return state;\n    }\n};\n\n// predictions reducer, governs hints above input box\nvar predictions = function predictions() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.UPDATE_PREDICTIONS:\n            return action.predictions;\n        default:\n            return state;\n    }\n};\n\n// docs reducer, governs what is displayed in docs pane\nvar docs = function docs() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { title: '', examples: [], description: [], source: '' };\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.UPDATE_DOCS:\n            return action.doc;\n        default:\n            return state;\n    }\n};\n\n// function search reducer, governs function search in the right sidebar\nvar functionSearch = function functionSearch() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { search: '', results: [] };\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.UPDATE_FUNC:\n            return _extends({}, state, { search: action.search });\n        case types.UPDATE_RESULTS:\n            return _extends({}, state, { results: action.results });\n        default:\n            return state;\n    }\n};\n\n// input reducer, manages current user input on main conversation pane\nvar currentInput = function currentInput() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { 'input': '', 'classIndex': null };\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.STORE_CURRENT_INPUT:\n            return _extends({}, state, { 'input': action.currentInput });\n        case types.STORE_CLASS_INDEX:\n            return _extends({}, state, { 'classIndex': action.class_index });\n        case types.CLEAR_CLASS_INDEX:\n            return _extends({}, state, { 'classIndex': null });\n        default:\n            return state;\n    }\n};\n\n// reducer that manages which pans are open and closed\n// TODO: this is a bad API, make more consistent\nvar minimizeState = function minimizeState() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { 'docs': true, 'code_edit': true };\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.SET_DOCS:\n            return _extends({}, state, { 'docs': action.docs });\n        case types.SET_CODE_EDIT:\n            return _extends({}, state, { 'code_edit': action.code_edit });\n        default:\n            return state;\n    }\n};\n\n// helper to create a new array/list with desired index removed\nvar removeIndex = function removeIndex(arr, i) {\n    var first_half = arr.concat([]).slice(0, i);\n    var second_half = arr.concat([]).slice(i + 1, arr.length);\n    return first_half.concat(second_half);\n};\n\nvar blankCommand = { name: '', title: '', args: [], examples: [], command: '', explanation: '', testInput: '', preview: '', error: '' };\n\n// reducer to manage the command editing pane\nvar commandEditPane = function commandEditPane() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _extends({}, blankCommand);\n    var action = arguments[1];\n\n    switch (action.type) {\n        case types.UPDATE_CODE_EDITOR:\n            var new_state = {};\n            new_state[action.name] = action.value;\n            return _extends({}, state, new_state);\n        case types.UPDATE_COMMAND:\n            console.log(_extends({}, state, action.command));\n            return _extends({}, state, action.command);\n        case types.ADD_COMMAND_ARG:\n            return _extends({}, state, { args: state.args.concat([{ 'arg_name': '', 'arg_type': '', 'arg_string': '' }]) });\n        case types.RESET_COMMAND:\n            return _extends({}, state, blankCommand);\n        case types.ADD_COMMAND_EXAMPLE:\n            return _extends({}, state, { examples: state.examples.concat(['']) });\n        case types.UPDATE_COMMAND_EXAMPLE:\n            var newExamples = state.examples.concat([]);\n            newExamples[action.id] = action.text;\n            return _extends({}, state, { examples: newExamples });\n        case types.UPDATE_COMMAND_ARG:\n            var newArgs = state.args.concat([]);\n            newArgs[action.id] = action.values;\n            return _extends({}, state, { args: newArgs });\n        case types.DELETE_COMMAND_ARG:\n            return _extends({}, state, { args: removeIndex(state.args, action.id) });\n        case types.DELETE_COMMAND_EXAMPLE:\n            return _extends({}, state, { examples: removeIndex(state.examples, action.id) });\n        default:\n            return state;\n    }\n};\n\n// reducer to manage the input history state, going through old commands with up/down arrow\nvar inputHistory = function inputHistory() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { 'history': [], 'currId': null, 'showHistory': false };\n    var action = arguments[1];\n\n    var newId = void 0;\n    switch (action.type) {\n        case types.ADD_INPUT_HISTORY:\n            var newHistory = [].concat(_toConsumableArray(state.history), [action.message]);\n            console.log(\"history\", newHistory, state.currId, newHistory.length - 1);\n            return _extends({}, state, { 'history': newHistory, 'currId': newHistory.length - 1 });\n        case types.MOVE_INPUT_HISTORY:\n            if (state.history.length === 0 || state.currId === null) {\n                console.log(\"history\", state.currId, newId);\n                return state;\n            }\n            newId = state.currId;\n            if (action.direction === 'up') {\n                if (newId >= 1) {\n                    newId -= 1;\n                }\n            } else {\n                if (newId < state.history.length - 1) {\n                    newId += 1;\n                }\n            }\n            console.log(\"history\", state.currId, newId);\n            return _extends({}, state, { 'currId': newId });\n        default:\n            return state;\n    }\n};\n\n// combine all these reducers together\nvar rootReducer = (0, _redux.combineReducers)({\n    conversation: conversation,\n    variables: variables,\n    predictions: predictions,\n    inputHistory: inputHistory,\n    currentInput: currentInput,\n    docs: docs,\n    functionSearch: functionSearch,\n    minimizeState: minimizeState,\n    commandEditPane: commandEditPane,\n    routing: _reactRouterRedux.routerReducer\n});\n\nexports.default = rootReducer;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvcmVkdWNlcnMvaW5kZXguanM/ZTkxNiJdLCJuYW1lcyI6WyJ0eXBlcyIsIl8iLCJ2YWx1ZU9yTnVsbCIsInZhbHVlIiwidW5kZWZpbmVkIiwiYXBwZW5kTWVzc2FnZXMiLCJvbGRNZXNzYWdlcyIsImFjdGlvbiIsIm5ld01lc3NhZ2VzIiwiY3VycmVudE1heCIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJtYXAiLCJtIiwiaWQiLCJtYXgiLCJ0ZXh0IiwiY2xhc3NfaW5kZXgiLCJwdXNoIiwib3JpZ2luIiwic3RhdGUiLCJhcmciLCJjb25jYXQiLCJhcHBlbmRNZXNzYWdlc0NvbnZvIiwiY29udm8iLCJtZXNzYWdlcyIsImFyZ3MiLCJhcmdfbWFwIiwiY29udmVyc2F0aW9uIiwiaGlzdG9yeSIsImN1cnJlbnRDb252byIsIm5ld0NvbnZvIiwidHlwZSIsIlVQREFURV9ISVNUT1JZIiwiQUREX01FU1NBR0UiLCJBRERfU0VSVkVSX01FU1NBR0UiLCJ0aGVJZCIsInRpdGxlIiwibGFiZWwiLCJISURFX0NPTlZFUlNBVElPTiIsIm5ld0hpc3RvcnkiLCJvdXQiLCJjb252IiwiaGlkZGVuIiwidmFyaWFibGVzIiwiVVBEQVRFX1ZBUklBQkxFUyIsIlRPR0dMRV9WQVJJQUJMRV9BVFRSSUJVVEVTIiwibmV3VmFyaWFibGVzIiwiaW5kZXgiLCJ2YWx1ZXMiLCJwcmVkaWN0aW9ucyIsIlVQREFURV9QUkVESUNUSU9OUyIsImRvY3MiLCJleGFtcGxlcyIsImRlc2NyaXB0aW9uIiwic291cmNlIiwiVVBEQVRFX0RPQ1MiLCJkb2MiLCJmdW5jdGlvblNlYXJjaCIsInNlYXJjaCIsInJlc3VsdHMiLCJVUERBVEVfRlVOQyIsIlVQREFURV9SRVNVTFRTIiwiY3VycmVudElucHV0IiwiU1RPUkVfQ1VSUkVOVF9JTlBVVCIsIlNUT1JFX0NMQVNTX0lOREVYIiwiQ0xFQVJfQ0xBU1NfSU5ERVgiLCJtaW5pbWl6ZVN0YXRlIiwiU0VUX0RPQ1MiLCJTRVRfQ09ERV9FRElUIiwiY29kZV9lZGl0IiwicmVtb3ZlSW5kZXgiLCJhcnIiLCJpIiwiZmlyc3RfaGFsZiIsInNsaWNlIiwic2Vjb25kX2hhbGYiLCJibGFua0NvbW1hbmQiLCJuYW1lIiwiY29tbWFuZCIsImV4cGxhbmF0aW9uIiwidGVzdElucHV0IiwicHJldmlldyIsImVycm9yIiwiY29tbWFuZEVkaXRQYW5lIiwiVVBEQVRFX0NPREVfRURJVE9SIiwibmV3X3N0YXRlIiwiVVBEQVRFX0NPTU1BTkQiLCJBRERfQ09NTUFORF9BUkciLCJSRVNFVF9DT01NQU5EIiwiQUREX0NPTU1BTkRfRVhBTVBMRSIsIlVQREFURV9DT01NQU5EX0VYQU1QTEUiLCJuZXdFeGFtcGxlcyIsIlVQREFURV9DT01NQU5EX0FSRyIsIm5ld0FyZ3MiLCJERUxFVEVfQ09NTUFORF9BUkciLCJERUxFVEVfQ09NTUFORF9FWEFNUExFIiwiaW5wdXRIaXN0b3J5IiwibmV3SWQiLCJBRERfSU5QVVRfSElTVE9SWSIsIm1lc3NhZ2UiLCJjdXJySWQiLCJNT1ZFX0lOUFVUX0hJU1RPUlkiLCJkaXJlY3Rpb24iLCJyb290UmVkdWNlciIsInJvdXRpbmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0lBQVlBLEs7O0FBQ1o7O0lBQVlDLEM7Ozs7OztBQUVaO0FBQ0EsSUFBTUMsY0FBYyxTQUFkQSxXQUFjLENBQUNDLEtBQUQsRUFBVztBQUMzQixRQUFJQSxVQUFVQyxTQUFkLEVBQXlCO0FBQ3JCLGVBQU9ELEtBQVA7QUFDSDtBQUNELFdBQU8sSUFBUDtBQUNILENBTEQ7O0FBT0E7QUFDQSxJQUFNRSxpQkFBaUIsU0FBakJBLGNBQWlCLENBQUNDLFdBQUQsRUFBY0MsTUFBZCxFQUF5QjtBQUM1QyxRQUFNQyxjQUFjLEVBQXBCO0FBQ0EsUUFBSUMsYUFBYSxDQUFqQjtBQUNBLFFBQUlILFlBQVlJLE1BQVosR0FBcUIsQ0FBekIsRUFBNEI7QUFDeEJDLGdCQUFRQyxHQUFSLENBQVksS0FBWixFQUFtQlgs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LG1CQUFPOUUsS0FBUDtBQXZCUjtBQXlCSCxDQTNCRDs7QUE2QkE7QUFDQSxJQUFNb0YsY0FBYyw0QkFBZ0I7QUFDaEM1RSw4QkFEZ0M7QUFFaENnQix3QkFGZ0M7QUFHaENNLDRCQUhnQztBQUloQytDLDhCQUpnQztBQUtoQ2xDLDhCQUxnQztBQU1oQ1gsY0FOZ0M7QUFPaENNLGtDQVBnQztBQVFoQ1MsZ0NBUmdDO0FBU2hDaUIsb0NBVGdDO0FBVWhDcUI7QUFWZ0MsQ0FBaEIsQ0FBcEI7O2tCQWFlRCxXIiwiZmlsZSI6IjUxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJvdXRlclJlZHVjZXIgYXMgcm91dGluZyB9IGZyb20gJ3JlYWN0LXJvdXRlci1yZWR1eCc7XG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgKiBhcyB0eXBlcyBmcm9tICcuLi9hY3Rpb25zL3R5cGVzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcblxuLy8gVE9ETzogYSBiaXQgY29uZnVzZWQgd2h5IHdlIG5lZWQgdGhpcyBmdW5jdGlvblxuY29uc3QgdmFsdWVPck51bGwgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLy8gZ2l2ZW4gYW4gYWN0aW9uLCBwdXNoIGFueSBuZXcgbWVzc2FnZXMgb250byBhbiBleGlzdGluZyBzZXQgb2YgbWVzc2FnZXNcbmNvbnN0IGFwcGVuZE1lc3NhZ2VzID0gKG9sZE1lc3NhZ2VzLCBhY3Rpb24pID0+IHtcbiAgICBjb25zdCBuZXdNZXNzYWdlcyA9IFtdO1xuICAgIGxldCBjdXJyZW50TWF4ID0gMDtcbiAgICBpZiAob2xkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnbWFwJywgXy5tYXAob2xkTWVzc2FnZXMsIGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0uaWQ7IH0pKTtcbiAgICAgICAgY3VycmVudE1heCA9IF8ubWF4KF8ubWFwKG9sZE1lc3NhZ2VzLCBmdW5jdGlvbihtKSB7IHJldHVybiBtLmlkOyB9KSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbSBvZiBhY3Rpb24udGV4dCkge1xuICAgICAgICBjdXJyZW50TWF4Kys7XG4gICAgICAgIGxldCBjbGFzc19pbmRleCA9IGFjdGlvbi5jbGFzc19pbmRleCAhPT0gdW5kZWZpbmVkID8gYWN0aW9uLmNsYXNzX2luZGV4IDogbnVsbDtcbiAgICAgICAgbmV3TWVzc2FnZXMucHVzaCh7J29yaWdpbic6IGFjdGlvbi5vcmlnaW4sICd0ZXh0JzogbSwgJ2lkJzogY3VycmVudE1heCwgJ2NsYXNzX2luZGV4JzogY2xhc3NfaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdzdGF0ZSc6IHZhbHVlT3JOdWxsKGFjdGlvbi5zdGF0ZSksICdhcmcnOiB2YWx1ZU9yTnVsbChhY3Rpb24uYXJnKX0pO1xuICAgIH1cbiAgICByZXR1cm4gb2xkTWVzc2FnZXMuY29uY2F0KG5ld01lc3NhZ2VzKTtcbn07XG5cbi8vIGdpdmVuIGFuIGFjdGlvbiwgdXBkYXRlIGEgY29udmVyc2F0aW9uIHdpdGggbmV3IG1lc3NhZ2VzXG5jb25zdCBhcHBlbmRNZXNzYWdlc0NvbnZvID0gKGNvbnZvLCBhY3Rpb24pID0+IHtcbiAgICBjb25zdCB7IG1lc3NhZ2VzIH0gPSBjb252bztcbiAgICByZXR1cm4geyAuLi5jb252bywgbWVzc2FnZXM6IGFwcGVuZE1lc3NhZ2VzKG1lc3NhZ2VzLCBhY3Rpb24pLCBhcmdzOiBhY3Rpb24uYXJnX21hcCB9O1xufTtcblxuLy8gcmVkdWNlciBmb3IgY29udmVyc2F0aW9uc1xuLy8gVE9ETzogVGhpcyBkZWZpbml0aW9uIHN0YXRlIGlzIHByZXR0eSBsb25nLCBtZXNzeVxuLy8gQWxzbyBub3QgY2xlYXIgd2hhdCBcImFyZ3NcIiByZXByZXNlbnRzIGluIGEgY29udmVyc2F0aW9uIHdpdGggbXVsdGlwbGUgc3ViLWNvbnZvc1xuLy8gTWF5YmUgaXQgaXMgb25seSBpbXBvcnRhbnQgdG8gcmVwcmVzZW50IHRoZSBjb252byB0aXRsZSwgaWYgc28gbWF5YmUgdGhhdCBzaG91bGQgYmUgcmVmYWN0b3JlZFxuY29uc3QgY29udmVyc2F0aW9uID0gKHN0YXRlID0geydoaXN0b3J5JzogW10sICdjdXJyZW50Q29udm8nOiB7ICdtZXNzYWdlcyc6IFtdLCAndGl0bGUnOiBudWxsLCAnaGlkZGVuJzogZmFsc2UsICdpZCc6IDAsICdhcmdzJzoge30gfSwgJ3N0YXRlJzogJ1NUQVJUJ30sIGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IHsgaGlzdG9yeSwgY3VycmVudENvbnZvIH0gPSBzdGF0ZTtcbiAgICBsZXQgbmV3Q29udm87XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLlVQREFURV9ISVNUT1JZOlxuICAgICAgICAgICAgY29uc29sZS5sb2coYWN0aW9uLmNvbnZlcnNhdGlvbi5jdXJyZW50Q29udm8pO1xuICAgICAgICAgICAgcmV0dXJuIHsgaGlzdG9yeTogYWN0aW9uLmNvbnZlcnNhdGlvbi5oaXN0b3J5LCBjdXJyZW50Q29udm86IGFjdGlvbi5jb252ZXJzYXRpb24uY3VycmVudENvbnZvLCAnc3RhdGUnOiBzdGF0ZS5zdGF0ZSB9O1xuICAgICAgICBjYXNlIHR5cGVzLkFERF9NRVNTQUdFOlxuICAgICAgICAgICAgcmV0dXJuIHsgaGlzdG9yeSwgY3VycmVudENvbnZvOiBhcHBlbmRNZXNzYWdlc0NvbnZvKGN1cnJlbnRDb252bywgYWN0aW9uKSwgJ3N0YXRlJzogc3RhdGUuc3RhdGUgfTtcbiAgICAgICAgLy8gdGhpcyBpcyBhIGJpdCBjb21wbGV4LCBtYXliZSBuZWVkcyByZXZpZXcgZm9yIGNsYXJpdHlcbiAgICAgICAgY2FzZSB0eXBlcy5BRERfU0VSVkVSX01FU1NBR0U6XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Q29udm8gPSBhcHBlbmRNZXNzYWdlc0NvbnZvKGN1cnJlbnRDb252bywgYWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uc3RhdGUgPT09ICdTVEFSVCcpIHtcbiAgICAgICAgICAgICAgICAvLyBoYXJkY29kaW5nIHNvbWUgbG9naWMgaGVyZSBmb3Igc3luY2luZyBoaXN0b3J5IHdpdGggc2VydmVyIG9uIFNUQVJUXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhbGxvd3Mgc29tZSBjb21tYW5kcyB0byBvdmVyd3JpdGUgaGlzdG9yeSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIGxldCB0aGVJZCA9IGFjdGlvbi5oaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBuZXdDb252byA9IHsuLi5uZXdDb252bywgdGl0bGU6IGFjdGlvbi5sYWJlbCwgaWQ6IHRoZUlkIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaGlzdG9yeTogYWN0aW9uLmhpc3RvcnkuY29uY2F0KFtuZXdDb252b10pLCAnY3VycmVudENvbnZvJzogeyAnbWVzc2FnZXMnOiBbXSwgJ3RpdGxlJzogbnVsbCwgJ2hpZGRlbic6IGZhbHNlLCAnaWQnOiBuZXdDb252by5pZCArIDEsICdhcmdzJzoge30gfSwgc3RhdGU6ICdTVEFSVCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGhpc3RvcnksIGN1cnJlbnRDb252bzogbmV3Q29udm8sIHN0YXRlOiBhY3Rpb24uc3RhdGUgfTtcbiAgICAgICAgY2FzZSB0eXBlcy5ISURFX0NPTlZFUlNBVElPTjpcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc3VwZXIgdmVyYm9zZSBqdXN0IHRvIHVwZGF0ZSBhIHNwZWNpZmljIGNvbnZvIGluZGV4LCBiZXR0ZXIgd2F5P1xuICAgICAgICAgICAgY29uc3QgbmV3SGlzdG9yeSA9IF8ubWFwKGhpc3RvcnksIGNvbnYgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IHsuLi5jb252fTtcbiAgICAgICAgICAgICAgICBpZiAoY29udi5pZCA9PT0gYWN0aW9uLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5oaWRkZW4gPSAhb3V0LmhpZGRlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVE9ETzogYWxzbyB3YXN0ZWZ1bCB0byBkbyBhIGNvcHkgZXZlcnl0aW1lLCBpbmRlbmRlbnQgb2YgdGhlIGluZGV4P1xuICAgICAgICAgICAgbmV3Q29udm8gPSB7Li4uY3VycmVudENvbnZvfTtcbiAgICAgICAgICAgIGlmIChuZXdDb252by5pZCA9PT0gYWN0aW9uLmlkKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29udm8uaGlkZGVuID0gIW5ld0NvbnZvLmhpZGRlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGhpc3Rvcnk6IG5ld0hpc3RvcnksIGN1cnJlbnRDb252bzogbmV3Q29udm8sIHN0YXRlOiBzdGF0ZS5zdGF0ZX07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufTtcblxuLy8gdmFyaWFibGVzIHJlZHVjZXIsIGNvbnN0cm9scyB2YXJpYWJsZXMgaW4gcmlnaHQgc2lkZWJhclxuY29uc3QgdmFyaWFibGVzID0gKHN0YXRlID0gW10sIGFjdGlvbikgPT4ge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlcy5VUERBVEVfVkFSSUFCTEVTOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi52YXJpYWJsZXM7XG4gICAgICAgIGNhc2UgdHlwZXMuVE9HR0xFX1ZBUklBQkxFX0FUVFJJQlVURVM6XG4gICAgICAgICAgICBsZXQgbmV3VmFyaWFibGVzID0gc3RhdGUuY29uY2F0KFtdKTtcbiAgICAgICAgICAgIG5ld1ZhcmlhYmxlc1thY3Rpb24uaW5kZXhdID0gYWN0aW9uLnZhbHVlcztcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG4vLyBwcmVkaWN0aW9ucyByZWR1Y2VyLCBnb3Zlcm5zIGhpbnRzIGFib3ZlIGlucHV0IGJveFxuY29uc3QgcHJlZGljdGlvbnMgPSAoc3RhdGUgPSBbXSwgYWN0aW9uKSA9PiB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLlVQREFURV9QUkVESUNUSU9OUzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24ucHJlZGljdGlvbnM7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufTtcblxuLy8gZG9jcyByZWR1Y2VyLCBnb3Zlcm5zIHdoYXQgaXMgZGlzcGxheWVkIGluIGRvY3MgcGFuZVxuY29uc3QgZG9jcyA9IChzdGF0ZSA9IHt0aXRsZTogJycsIGV4YW1wbGVzOiBbXSwgZGVzY3JpcHRpb246IFtdLCBzb3VyY2U6Jyd9LCBhY3Rpb24pID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMuVVBEQVRFX0RPQ1M6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmRvYztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG4vLyBmdW5jdGlvbiBzZWFyY2ggcmVkdWNlciwgZ292ZXJucyBmdW5jdGlvbiBzZWFyY2ggaW4gdGhlIHJpZ2h0IHNpZGViYXJcbmNvbnN0IGZ1bmN0aW9uU2VhcmNoID0gKHN0YXRlID0ge3NlYXJjaDogJycsIHJlc3VsdHM6IFtdfSwgYWN0aW9uKSA9PiB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpe1xuICAgIGNhc2UgdHlwZXMuVVBEQVRFX0ZVTkM6XG4gICAgICByZXR1cm4gey4uLnN0YXRlLCBzZWFyY2g6IGFjdGlvbi5zZWFyY2h9O1xuICAgIGNhc2UgdHlwZXMuVVBEQVRFX1JFU1VMVFM6XG4gICAgICByZXR1cm4gey4uLnN0YXRlLCByZXN1bHRzOiBhY3Rpb24ucmVzdWx0c307XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcblxuLy8gaW5wdXQgcmVkdWNlciwgbWFuYWdlcyBjdXJyZW50IHVzZXIgaW5wdXQgb24gbWFpbiBjb252ZXJzYXRpb24gcGFuZVxuY29uc3QgY3VycmVudElucHV0ID0gKHN0YXRlID0geydpbnB1dCc6ICcnLCAnY2xhc3NJbmRleCc6IG51bGx9LCBhY3Rpb24pID0+IHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSl7XG4gICAgY2FzZSB0eXBlcy5TVE9SRV9DVVJSRU5UX0lOUFVUOlxuICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgJ2lucHV0JzogYWN0aW9uLmN1cnJlbnRJbnB1dH07XG4gICAgY2FzZSB0eXBlcy5TVE9SRV9DTEFTU19JTkRFWDpcbiAgICAgIHJldHVybiB7Li4uc3RhdGUsICdjbGFzc0luZGV4JzogYWN0aW9uLmNsYXNzX2luZGV4fTtcbiAgICBjYXNlIHR5cGVzLkNMRUFSX0NMQVNTX0lOREVYOlxuICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgJ2NsYXNzSW5kZXgnOiBudWxsfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xuXG4vLyByZWR1Y2VyIHRoYXQgbWFuYWdlcyB3aGljaCBwYW5zIGFyZSBvcGVuIGFuZCBjbG9zZWRcbi8vIFRPRE86IHRoaXMgaXMgYSBiYWQgQVBJLCBtYWtlIG1vcmUgY29uc2lzdGVudFxuY29uc3QgbWluaW1pemVTdGF0ZSA9IChzdGF0ZT17J2RvY3MnOiB0cnVlLCAnY29kZV9lZGl0Jzp0cnVlfSwgYWN0aW9uKSA9PiB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpe1xuICAgIGNhc2UgdHlwZXMuU0VUX0RPQ1M6XG4gICAgICByZXR1cm4gey4uLnN0YXRlLCAnZG9jcyc6IGFjdGlvbi5kb2NzfTtcbiAgICBjYXNlIHR5cGVzLlNFVF9DT0RFX0VESVQ6XG4gICAgICByZXR1cm4gey4uLnN0YXRlLCAnY29kZV9lZGl0JzogYWN0aW9uLmNvZGVfZWRpdH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcblxuLy8gaGVscGVyIHRvIGNyZWF0ZSBhIG5ldyBhcnJheS9saXN0IHdpdGggZGVzaXJlZCBpbmRleCByZW1vdmVkXG5jb25zdCByZW1vdmVJbmRleCA9IChhcnIsIGkpID0+IHtcbiAgbGV0IGZpcnN0X2hhbGYgPSBhcnIuY29uY2F0KFtdKS5zbGljZSgwLCBpKTtcbiAgbGV0IHNlY29uZF9oYWxmID0gYXJyLmNvbmNhdChbXSkuc2xpY2UoaSsxLGFyci5sZW5ndGgpO1xuICByZXR1cm4gZmlyc3RfaGFsZi5jb25jYXQoc2Vjb25kX2hhbGYpO1xufVxuXG5jb25zdCBibGFua0NvbW1hbmQgPSB7bmFtZTogJycsIHRpdGxlOiAnJywgYXJnczogW10sIGV4YW1wbGVzOiBbXSwgY29tbWFuZDogJycsIGV4cGxhbmF0aW9uOiAnJywgdGVzdElucHV0OiAnJywgcHJldmlldzonJywgZXJyb3I6ICcnfTtcblxuLy8gcmVkdWNlciB0byBtYW5hZ2UgdGhlIGNvbW1hbmQgZWRpdGluZyBwYW5lXG5jb25zdCBjb21tYW5kRWRpdFBhbmUgPSAoc3RhdGU9ey4uLmJsYW5rQ29tbWFuZH0sIGFjdGlvbikgPT4ge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKXtcbiAgICBjYXNlIHR5cGVzLlVQREFURV9DT0RFX0VESVRPUjpcbiAgICAgIGxldCBuZXdfc3RhdGUgPSB7fTtcbiAgICAgIG5ld19zdGF0ZVthY3Rpb24ubmFtZV0gPSBhY3Rpb24udmFsdWU7XG4gICAgICByZXR1cm4gey4uLnN0YXRlLCAuLi5uZXdfc3RhdGV9O1xuICAgIGNhc2UgdHlwZXMuVVBEQVRFX0NPTU1BTkQ6XG4gICAgICBjb25zb2xlLmxvZyh7Li4uc3RhdGUsIC4uLmFjdGlvbi5jb21tYW5kfSk7XG4gICAgICByZXR1cm4gey4uLnN0YXRlLCAuLi5hY3Rpb24uY29tbWFuZH07XG4gICAgY2FzZSB0eXBlcy5BRERfQ09NTUFORF9BUkc6XG4gICAgICByZXR1cm4gey4uLnN0YXRlLCBhcmdzOiBzdGF0ZS5hcmdzLmNvbmNhdChbeydhcmdfbmFtZSc6ICcnLCAnYXJnX3R5cGUnOiAnJywgJ2FyZ19zdHJpbmcnOiAnJ31dKX07XG4gICAgY2FzZSB0eXBlcy5SRVNFVF9DT01NQU5EOlxuICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgLi4uYmxhbmtDb21tYW5kfTtcbiAgICBjYXNlIHR5cGVzLkFERF9DT01NQU5EX0VYQU1QTEU6XG4gICAgICByZXR1cm4gey4uLnN0YXRlLCBleGFtcGxlczogc3RhdGUuZXhhbXBsZXMuY29uY2F0KFsnJ10pfTtcbiAgICBjYXNlIHR5cGVzLlVQREFURV9DT01NQU5EX0VYQU1QTEU6XG4gICAgICBsZXQgbmV3RXhhbXBsZXMgPSBzdGF0ZS5leGFtcGxlcy5jb25jYXQoW10pO1xuICAgICAgbmV3RXhhbXBsZXNbYWN0aW9uLmlkXSA9IGFjdGlvbi50ZXh0O1xuICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgZXhhbXBsZXM6IG5ld0V4YW1wbGVzfTtcbiAgICBjYXNlIHR5cGVzLlVQREFURV9DT01NQU5EX0FSRzpcbiAgICAgIGxldCBuZXdBcmdzID0gc3RhdGUuYXJncy5jb25jYXQoW10pO1xuICAgICAgbmV3QXJnc1thY3Rpb24uaWRdID0gYWN0aW9uLnZhbHVlcztcbiAgICAgIHJldHVybiB7Li4uc3RhdGUsIGFyZ3M6IG5ld0FyZ3N9O1xuICAgIGNhc2UgdHlwZXMuREVMRVRFX0NPTU1BTkRfQVJHOlxuICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgYXJnczogcmVtb3ZlSW5kZXgoc3RhdGUuYXJncywgYWN0aW9uLmlkKX07XG4gICAgY2FzZSB0eXBlcy5ERUxFVEVfQ09NTUFORF9FWEFNUExFOlxuICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgZXhhbXBsZXM6IHJlbW92ZUluZGV4KHN0YXRlLmV4YW1wbGVzLCBhY3Rpb24uaWQpfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xuXG4vLyByZWR1Y2VyIHRvIG1hbmFnZSB0aGUgaW5wdXQgaGlzdG9yeSBzdGF0ZSwgZ29pbmcgdGhyb3VnaCBvbGQgY29tbWFuZHMgd2l0aCB1cC9kb3duIGFycm93XG5jb25zdCBpbnB1dEhpc3RvcnkgPSAoc3RhdGUgPSB7J2hpc3RvcnknOiBbXSwgJ2N1cnJJZCc6IG51bGwsICdzaG93SGlzdG9yeSc6IGZhbHNlIH0sIGFjdGlvbikgPT4ge1xuICAgIGxldCBuZXdJZDtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMuQUREX0lOUFVUX0hJU1RPUlk6XG4gICAgICAgICAgICBjb25zdCBuZXdIaXN0b3J5ID0gWy4uLnN0YXRlLmhpc3RvcnksIGFjdGlvbi5tZXNzYWdlXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaGlzdG9yeVwiLCBuZXdIaXN0b3J5LCBzdGF0ZS5jdXJySWQsIG5ld0hpc3RvcnkubGVuZ3RoLTEpO1xuICAgICAgICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgJ2hpc3RvcnknOiBuZXdIaXN0b3J5LCAnY3VycklkJzogbmV3SGlzdG9yeS5sZW5ndGgtMX07XG4gICAgICAgIGNhc2UgdHlwZXMuTU9WRV9JTlBVVF9ISVNUT1JZOlxuICAgICAgICAgICAgaWYgKHN0YXRlLmhpc3RvcnkubGVuZ3RoID09PSAwIHx8IHN0YXRlLmN1cnJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaGlzdG9yeVwiLCBzdGF0ZS5jdXJySWQsIG5ld0lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJZCA9IHN0YXRlLmN1cnJJZDtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0lkID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SWQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChuZXdJZCA8IChzdGF0ZS5oaXN0b3J5Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0lkICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJoaXN0b3J5XCIsIHN0YXRlLmN1cnJJZCwgbmV3SWQpO1xuICAgICAgICAgICAgcmV0dXJuIHsuLi5zdGF0ZSwgJ2N1cnJJZCc6IG5ld0lkIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufTtcblxuLy8gY29tYmluZSBhbGwgdGhlc2UgcmVkdWNlcnMgdG9nZXRoZXJcbmNvbnN0IHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgICBjb252ZXJzYXRpb24sXG4gICAgdmFyaWFibGVzLFxuICAgIHByZWRpY3Rpb25zLFxuICAgIGlucHV0SGlzdG9yeSxcbiAgICBjdXJyZW50SW5wdXQsXG4gICAgZG9jcyxcbiAgICBmdW5jdGlvblNlYXJjaCxcbiAgICBtaW5pbWl6ZVN0YXRlLFxuICAgIGNvbW1hbmRFZGl0UGFuZSxcbiAgICByb3V0aW5nXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdFJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvcmVkdWNlcnMvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ })

})